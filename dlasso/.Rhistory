ti_c3 <- system.time({
res_gibbs_c3 <- bayesian_lasso_gibbs_tune_pgtn_c(
mX,
vy,
lambda = res_mfvb_tune_c2$lambda2_til,
sigma2_hat = 1 / res_mfvb_tune_c2$sigma2inv_til,
nburn = nburn,
nsamples = nsamples,
a = a,
b = b,
u = u,
v = v,
verbose = TRUE,
trunc = 0
)
})[3]
View(bayesian_lasso_gibbs_tune_pgtn_c)
ti_c3 <- system.time({
res_gibbs_c3 <- bayesian_lasso_gibbs_tune_pgtn_c(
mX,
vy,
lambda = res_mfvb$lambda2_til,
sigma2_hat = 1 / res_mfvb$sigma2inv_til,
nburn = nburn,
nsamples = nsamples,
a = a,
b = b,
u = u,
v = v,
verbose = TRUE,
trunc = 0
)
})[3]
ESS_c3 <- c()
for(j in 1:ncol(mX)){
ESS_c3[j] = ess_bulk(res_gibbs_c3$mBeta[,j])
}
Ef_c3 = summary(ESS_c3)/as.numeric(ti_c3)
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
# Calling package EBglmnet
#library(EBglmnet)
# Calling some required packages
library(invgamma)
library(mvtnorm)
#library(LassoDistribution)
source("lasso_distribution.R")
library(armspp)
library(psych)  # For getting the trace of matrix
library(posterior)
# Calling package lars to load dataset
library(lars)
# Calling this package for getting ESS
# library(mcmcse)
library(here)
library(dplyr)
library(hdi)
data(riboflavin)
dataset_name <- "riboflavin"
y <- riboflavin$y
x <- riboflavin$x
######------- Normalizing variables ------
normalize <- function(y, X) {
n <- length(y)
p <- ncol(X)
mu.y <- mean(y)
sigma2.y <- (n - 1) * var(y) / n
vy <- (y - mu.y) / sqrt(sigma2.y)
# Normalise covariates
mX <- matrix(0, n, p)
mu.x <- c()
sigma2.x <- c()
for (j in 1:p)
{
mu.x[j] <- mean(X[, j])
sigma2.x[j] <- (n - 1) * var(X[, j]) / n
mX[, j] <- (X[, j] - mu.x[j]) / sqrt(sigma2.x[j])
}
return(list(vy = vy, mX = mX, mu.y = mu.y, sigma2.y = sigma2.y, mu.x = mu.x, sigma2.x = sigma2.x))
}
norm = normalize(y,x)
y <- norm$vy
x <- norm$mX
vy <- y
mX <- x
norm <- NULL
x <- NULL
y <- NULL
p <- ncol(mX)
n <- nrow(mX)
res <- svd(mX)
vd <- res$d
vlambda <- vd*vd
valpha <- seq(0,10000,length=500)
vdof <- c()
for (i in 1:length(valpha)) {
vdof[i] <- sum( vlambda/(vlambda + valpha[i]) )
}
target <- 2*sqrt(n)
alpha <- valpha[which.min(abs(vdof - target))]
vbeta_ml <- solve(t(mX)%*%mX + alpha*diag(p),t(mX)%*%vy)
sigma2_ml <- sum( (vy - mX%*%vbeta_ml)^2 )/n
lambda0 <- sqrt(alpha*sigma2_ml)
u <- 1.0E-8
v <- 1.0E-8
a <- 1.0E-8
b <- 1.0E-8
lambda0 <- 150
lambda_prior <- list(lambda_start=lambda0, prior="gamma",u=u,v=v)
source(here("code","bayesian_lasso_mfvb.R"))
ti_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda_prior, sigma2_hat=sigma2_ml, a, b, maxiter = 1000, tol = 1.0E-7)
})[3]
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 1000
nkeep <- 20000
nsamples <- nburn + nkeep
res_gibbs1 <- NULL
lambda_prior <- list(lambda_start=res_mfvb$lambda2_til, prior="gamma",u=u,v=v)
library(RcppClock)
library(statmod)
library(Rcpp)
sourceCpp("bayesian_lasso_gibbs.cpp", verbose = FALSE, showOutput = FALSE, echo=FALSE)
ti_c3 <- system.time({
res_gibbs_c3 <- bayesian_lasso_gibbs_tune_pgtn_c(
mX,
vy,
lambda = res_mfvb$lambda2_til,
sigma2_hat = 1 / res_mfvb$sigma2inv_til,
nburn = nburn,
nsamples = nsamples,
a = a,
b = b,
u = u,
v = v,
verbose = TRUE,
trunc = 0
)
})[3]
ESS_c3 <- c()
for(j in 1:ncol(mX)){
ESS_c3[j] = ess_bulk(res_gibbs_c3$mBeta[,j])
}
Ef_c3 = summary(ESS_c3)/as.numeric(ti_c3)
library(Rcpp)
sourceCpp("lasso_gibbs_2A.cpp", verbose = FALSE, showOutput = FALSE, cleanupCacheDir=TRUE, echo=FALSE)
ti_Ac <- system.time({
res_Ac <- lasso_gibbs_A_c(mX, vy, a=a, b=b, u=u, v=v,
nsamples=nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda_init=res_mfvb$lambda2_til,
sigma2_init=1/res_mfvb$sigma2inv_til)
})[3]
mBeta_mcmc = res_Ac$mBeta[-(1:nburn),]
ESS_Ac <- c()
for(j in 1:p){
ESS_Ac[j] <- ess_bulk(mBeta_mcmc[,j])
}
Ef_Ac = summary(ESS_Ac)/as.numeric(ti_Ac)
source("lasso_gibbs_2B.R")
source("lasso_distribution.R")
ti_B  <- system.time({
output_B = lasso_gibbs_2B(mX,vy,a,b,u,v,nsamples, res_mfvb$vmu_til, lambda2, sigma2 )
})[3]
plot(density(res_Ac$mBeta[,1]))
plot(density(res_Ac$mBeta[,2]))
plot(density(res_Ac$mBeta[,3]))
plot(density(res_Ac$mBeta[,4]))
plot(density(res_Ac$vsigma2))
plot(density(res_Ac$vlambda2))
apply(res_Ac$mBeta,1,mean)
apply(res_Ac$mBeta,2,mean)
length( apply(res_Ac$mBeta,1,mean) )
length( apply(res_Ac$mBeta,2,mean) )
abs( apply(res_Ac$mBeta,2,mean) )
max( abs( apply(res_Ac$mBeta,2,mean) ))
ess_basic( res_Ac$vsigma2 )
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
# Calling package EBglmnet
#library(EBglmnet)
# Calling some required packages
library(invgamma)
library(mvtnorm)
#library(LassoDistribution)
source("lasso_distribution.R")
library(armspp)
library(psych)  # For getting the trace of matrix
library(posterior)
# Calling package lars to load dataset
library(lars)
# Calling this package for getting ESS
# library(mcmcse)
library(here)
library(dplyr)
ess_basic( res_Ac$vsigma2 )
ess_basic( res_gibbs_c3$vsigma2 )
source("lasso_gibbs_2B.R")
source("lasso_distribution.R")
ti_B  <- system.time({
output_B = lasso_gibbs_2B(mX,vy,a,b,u,v,nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda2_init=res_mfvb$lambda2_til,
sigma2=1/res_mfvb$sigma2inv_til )
})[3]
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
# Calling package EBglmnet
#library(EBglmnet)
# Calling some required packages
library(invgamma)
library(mvtnorm)
#library(LassoDistribution)
source("lasso_distribution.R")
library(armspp)
library(psych)  # For getting the trace of matrix
library(posterior)
# Calling package lars to load dataset
library(lars)
# Calling this package for getting ESS
# library(mcmcse)
library(here)
library(dplyr)
library(hdi)
data(riboflavin)
dataset_name <- "riboflavin"
y <- riboflavin$y
x <- riboflavin$x
######------- Normalizing variables ------
normalize <- function(y, X) {
n <- length(y)
p <- ncol(X)
mu.y <- mean(y)
sigma2.y <- (n - 1) * var(y) / n
vy <- (y - mu.y) / sqrt(sigma2.y)
# Normalise covariates
mX <- matrix(0, n, p)
mu.x <- c()
sigma2.x <- c()
for (j in 1:p)
{
mu.x[j] <- mean(X[, j])
sigma2.x[j] <- (n - 1) * var(X[, j]) / n
mX[, j] <- (X[, j] - mu.x[j]) / sqrt(sigma2.x[j])
}
return(list(vy = vy, mX = mX, mu.y = mu.y, sigma2.y = sigma2.y, mu.x = mu.x, sigma2.x = sigma2.x))
}
norm = normalize(y,x)
y <- norm$vy
x <- norm$mX
vy <- y
mX <- x
norm <- NULL
x <- NULL
y <- NULL
p <- ncol(mX)
n <- nrow(mX)
res <- svd(mX)
vd <- res$d
vlambda <- vd*vd
valpha <- seq(0,10000,length=500)
vdof <- c()
for (i in 1:length(valpha)) {
vdof[i] <- sum( vlambda/(vlambda + valpha[i]) )
}
target <- 2*sqrt(n)
alpha <- valpha[which.min(abs(vdof - target))]
vbeta_ml <- solve(t(mX)%*%mX + alpha*diag(p),t(mX)%*%vy)
sigma2_ml <- sum( (vy - mX%*%vbeta_ml)^2 )/n
lambda0 <- sqrt(alpha*sigma2_ml)
u <- 1.0E-8
v <- 1.0E-8
a <- 1.0E-8
b <- 1.0E-8
lambda0 <- 1
lambda_prior <- list(lambda_start=lambda0, prior="gamma",u=u,v=v)
source(here("code","bayesian_lasso_mfvb.R"))
ti_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda_prior, sigma2_hat=sigma2_ml, a, b, maxiter = 1000, tol = 1.0E-7)
})[3]
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 1000
nkeep <- 20000
nsamples <- nburn + nkeep
res_gibbs1 <- NULL
lambda_prior <- list(lambda_start=res_mfvb$lambda2_til, prior="gamma",u=u,v=v)
library(RcppClock)
library(statmod)
library(Rcpp)
sourceCpp("bayesian_lasso_gibbs.cpp", verbose = FALSE, showOutput = FALSE, echo=FALSE)
ti_c3 <- system.time({
res_gibbs_c3 <- bayesian_lasso_gibbs_tune_pgtn_c(
mX,
vy,
lambda = res_mfvb$lambda2_til,
sigma2_hat = 1 / res_mfvb$sigma2inv_til,
nburn = nburn,
nsamples = nsamples,
a = a,
b = b,
u = u,
v = v,
verbose = TRUE,
trunc = 0
)
})[3]
ESS_c3 <- c()
for(j in 1:ncol(mX)){
ESS_c3[j] = ess_bulk(res_gibbs_c3$mBeta[,j])
}
Ef_c3 = summary(ESS_c3)/as.numeric(ti_c3)
library(Rcpp)
sourceCpp("lasso_gibbs_2A.cpp", verbose = FALSE, showOutput = FALSE, cleanupCacheDir=TRUE, echo=FALSE)
ti_Ac <- system.time({
res_Ac <- lasso_gibbs_A_c(mX, vy, a=a, b=b, u=u, v=v,
nsamples=nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda_init=res_mfvb$lambda2_til,
sigma2_init=1/res_mfvb$sigma2inv_til)
})[3]
mBeta_mcmc = res_Ac$mBeta[-(1:nburn),]
ESS_Ac <- c()
for(j in 1:p){
ESS_Ac[j] <- ess_bulk(mBeta_mcmc[,j])
}
Ef_Ac = summary(ESS_Ac)/as.numeric(ti_Ac)
source("lasso_gibbs_2B.R")
source("lasso_distribution.R")
ti_B  <- system.time({
output_B = lasso_gibbs_2B(mX,vy,a,b,u,v,nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda2_init=res_mfvb$lambda2_til,
sigma2=1/res_mfvb$sigma2inv_til )
})[3]
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
# Calling package EBglmnet
#library(EBglmnet)
# Calling some required packages
library(invgamma)
library(mvtnorm)
#library(LassoDistribution)
source("lasso_distribution.R")
library(armspp)
library(psych)  # For getting the trace of matrix
library(posterior)
# Calling package lars to load dataset
library(lars)
# Calling this package for getting ESS
# library(mcmcse)
library(here)
library(dplyr)
library(hdi)
data(riboflavin)
dataset_name <- "riboflavin"
y <- riboflavin$y
x <- riboflavin$x
######------- Normalizing variables ------
normalize <- function(y, X) {
n <- length(y)
p <- ncol(X)
mu.y <- mean(y)
sigma2.y <- (n - 1) * var(y) / n
vy <- (y - mu.y) / sqrt(sigma2.y)
# Normalise covariates
mX <- matrix(0, n, p)
mu.x <- c()
sigma2.x <- c()
for (j in 1:p)
{
mu.x[j] <- mean(X[, j])
sigma2.x[j] <- (n - 1) * var(X[, j]) / n
mX[, j] <- (X[, j] - mu.x[j]) / sqrt(sigma2.x[j])
}
return(list(vy = vy, mX = mX, mu.y = mu.y, sigma2.y = sigma2.y, mu.x = mu.x, sigma2.x = sigma2.x))
}
norm = normalize(y,x)
y <- norm$vy
x <- norm$mX
vy <- y
mX <- x
norm <- NULL
x <- NULL
y <- NULL
p <- ncol(mX)
n <- nrow(mX)
res <- svd(mX)
vd <- res$d
vlambda <- vd*vd
valpha <- seq(0,10000,length=500)
vdof <- c()
for (i in 1:length(valpha)) {
vdof[i] <- sum( vlambda/(vlambda + valpha[i]) )
}
target <- 2*sqrt(n)
alpha <- valpha[which.min(abs(vdof - target))]
vbeta_ml <- solve(t(mX)%*%mX + alpha*diag(p),t(mX)%*%vy)
sigma2_ml <- sum( (vy - mX%*%vbeta_ml)^2 )/n
lambda0 <- sqrt(alpha*sigma2_ml)
u <- 1
v <- 1.0E-4
a <- 1.0E-8
b <- 1.0E-8
lambda0 <- 200
lambda_prior <- list(lambda_start=lambda0, prior="gamma",u=u,v=v)
source(here("code","bayesian_lasso_mfvb.R"))
ti_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda_prior, sigma2_hat=sigma2_ml, a, b, maxiter = 1000, tol = 1.0E-7)
})[3]
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 1000
nkeep <- 20000
nsamples <- nburn + nkeep
res_gibbs1 <- NULL
lambda_prior <- list(lambda_start=res_mfvb$lambda2_til, prior="gamma",u=u,v=v)
library(RcppClock)
library(statmod)
library(Rcpp)
sourceCpp("bayesian_lasso_gibbs.cpp", verbose = FALSE, showOutput = FALSE, echo=FALSE)
ti_c3 <- system.time({
res_gibbs_c3 <- bayesian_lasso_gibbs_tune_pgtn_c(
mX,
vy,
lambda = res_mfvb$lambda2_til,
sigma2_hat = 1 / res_mfvb$sigma2inv_til,
nburn = nburn,
nsamples = nsamples,
a = a,
b = b,
u = u,
v = v,
verbose = TRUE,
trunc = 0
)
})[3]
ESS_c3 <- c()
for(j in 1:ncol(mX)){
ESS_c3[j] = ess_bulk(res_gibbs_c3$mBeta[,j])
}
Ef_c3 = summary(ESS_c3)/as.numeric(ti_c3)
library(Rcpp)
sourceCpp("lasso_gibbs_2A.cpp", verbose = FALSE, showOutput = FALSE, cleanupCacheDir=TRUE, echo=FALSE)
ti_Ac <- system.time({
res_Ac <- lasso_gibbs_A_c(mX, vy, a=a, b=b, u=u, v=v,
nsamples=nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda_init=res_mfvb$lambda2_til,
sigma2_init=1/res_mfvb$sigma2inv_til)
})[3]
mBeta_mcmc = res_Ac$mBeta[-(1:nburn),]
ESS_Ac <- c()
for(j in 1:p){
ESS_Ac[j] <- ess_bulk(mBeta_mcmc[,j])
}
Ef_Ac = summary(ESS_Ac)/as.numeric(ti_Ac)
source("lasso_gibbs_2B.R")
source("lasso_distribution.R")
ti_B  <- system.time({
output_B = lasso_gibbs_2B(mX,vy,a,b,u,v,nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda2_init=res_mfvb$lambda2_til,
sigma2=1/res_mfvb$sigma2inv_til )
})[3]
mBeta_mcmc = output_B$mBeta_mcmc[-(1:nburn),]
ESS_B <- c()
for(j in 1:p){
ESS_B[j] <- ess_bulk(mBeta_mcmc[,j])
}
Ef_B = summary(ESS_B)/as.numeric(ti_B)
save(output_B,file = "output_B.Rdata")
output_B = NULL
ord <- order(abs(res_bem$vbeta), decreasing = TRUE)
u <- 1.0E-4
v <- 1.0E-4
a <- 1.0E-8
b <- 1.0E-8
lambda0 <- 200
lambda_prior <- list(lambda_start=lambda0, prior="gamma",u=u,v=v)
ti_Ac <- system.time({
res_Ac <- lasso_gibbs_A_c(mX, vy, a=a, b=b, u=u, v=v,
nsamples=nsamples,
vbeta_init=res_mfvb$vmu_til,
lambda_init=res_mfvb$lambda2_til,
sigma2_init=1/res_mfvb$sigma2inv_til)
})[3]
mBeta_mcmc = res_Ac$mBeta[-(1:nburn),]
ESS_Ac <- c()
for(j in 1:p){
ESS_Ac[j] <- ess_bulk(mBeta_mcmc[,j])
}
Ef_Ac = summary(ESS_Ac)/as.numeric(ti_Ac)
knitr::opts_chunk$set(echo = TRUE)
library(Rcpp)
sourceCpp("rinvgaussian.cpp", echo=FALSE)
N <- 1000000
vm <- rep(1.0E20,N)
vl <- rep(1,N)
vx1 <- rinvgaussian_c(vm, vl)
vx2 <- rinvgaussian(N, vm, vl)
vx3 <- statmod::rinvgauss(N, vm, vl)
vx4 <- rrinvgauss(vm, vl)
plot(density(vx1))
lines(density(vx2),col="blue")
lines(density(vx3),col="red")
lines(density(vx4),col="green")
library(microbenchmark)
microbenchmark(rinvgaussian_c(vm, vl),
rinvgaussian(N, vm, vl),
statmod::rinvgauss(N, vm, vl),
rrinvgauss(vm, vl))
version
install.packages("rmarkdown")
