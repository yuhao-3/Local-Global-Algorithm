res <- univariate_local_global(vy, mX, lambda,
vmu_init=res_mfvb$vmu_til,
mSigma_init=res_mfvb$vsigma2_til,
a_til=res_mfvb$a_til,
b_til=res_mfvb$b_til)
})[3]
}
ti_LGU
source("bivariate_local_global.R")
set.seed(333)
lambda = exp(lgamma(res_mfvb$u_til+0.5) - lgamma(res_mfvb$u_til) - 0.5*log(res_mfvb$v_til))
ti_LGB <- system.time({
res_bv <- bivariate_local_global(vy, mX, lambda,
vmu_init=res$vmu_til,
mSigma_init=res$mSigma_til,
a_til=res_mfvb$a_til,
b_til=res_mfvb$b_til,
damp=0.005)
})[3]
ti_LGB
save.image(here("../results",paste("results",dataset_name,".Rdata",sep="")))
#load(here("results",paste("results",dataset_name,".Rdata",sep="")))
plot_densities <- function(ldens, cols, exclude, gold, threshold = 0.2) {
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k %in% exclude)) {
# Consider only the x and y values where y > threshold
subset_ldens <- subset(ldens[[k]], y > threshold)
xlim <- range(c(xlim, subset_ldens$x), finite = TRUE)
ylim <- range(c(ylim, subset_ldens$y), finite = TRUE)
}
}
# xlim =  c(-0.2,0.2)
# ylim = c(0,5)
plot(NA, type = "n", xlim = xlim, ylim = ylim, xlab = "x", ylab = "density")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x, ldens[[k]]$y, col = cols[k], lwd = 3)
acc <- 1 - 0.5 * trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res$vmu_til
vsigma_LG <- sqrt(diag(res$mSigma_til))
# pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 10, height= 8)
cols <- c("purple","green", "blue", "red", "purple")
exclude <- c()
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.65
pcntL <- 0.2
pcntT <- 0.65
pcntR <- 0.2
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(1,1),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,4,p)
all_ldens = list()
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dens$y)
ldens[[2]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[3]] <- list(x=xg, y = dlasso(xg,res$a[j], res$b[j], res$c_val))
ldens[[4]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
all_ldens[[j]] = ldens
vacc <- plot_densities(ldens, cols, exclude, gold=1)
mAcc[,j] <- vacc
methods <- c("MCMC", "VB", "LG_Local", "LG_Global")
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
res
res_bv
plot_densities <- function(ldens, cols, exclude, gold, threshold = 0.2) {
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k %in% exclude)) {
# Consider only the x and y values where y > threshold
subset_ldens <- subset(ldens[[k]], y > threshold)
xlim <- range(c(xlim, subset_ldens$x), finite = TRUE)
ylim <- range(c(ylim, subset_ldens$y), finite = TRUE)
}
}
# xlim =  c(-0.2,0.2)
# ylim = c(0,5)
plot(NA, type = "n", xlim = xlim, ylim = ylim, xlab = "x", ylab = "density")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x, ldens[[k]]$y, col = cols[k], lwd = 3)
acc <- 1 - 0.5 * trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res$vmu_til
vsigma_LG <- sqrt(diag(res$mSigma_til))
# pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 10, height= 8)
cols <- c("purple","green", "blue", "red", "purple")
exclude <- c()
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.65
pcntL <- 0.2
pcntT <- 0.65
pcntR <- 0.2
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(1,1),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,4,p)
all_ldens = list()
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dens$y)
ldens[[2]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[3]] <- list(x=xg, y = dlasso(xg,res$a[j], res$b[j], res$c_val))
ldens[[4]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
all_ldens[[j]] = ldens
vacc <- plot_densities(ldens, cols, exclude, gold=1)
mAcc[,j] <- vacc
methods <- c("MCMC", "VB", "LG_Local", "LG_Global")
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
plot_densities <- function(ldens, cols, exclude, gold, threshold = 0.2) {
vacc <- c()
xlim <- c()
ylim <- c()
# for (k in 1:length(ldens)) {
#  if (!(k %in% exclude)) {
#   # Consider only the x and y values where y > threshold
#  subset_ldens <- subset(ldens[[k]], y > threshold)
# xlim <- range(c(xlim, subset_ldens$x), finite = TRUE)
#  ylim <- range(c(ylim, subset_ldens$y), finite = TRUE)
#}
#}
xlim =  c(-0.2,0.2)
ylim = c(0,5)
plot(NA, type = "n", xlim = xlim, ylim = ylim, xlab = "x", ylab = "density")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x, ldens[[k]]$y, col = cols[k], lwd = 3)
acc <- 1 - 0.5 * trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res$vmu_til
vsigma_LG <- sqrt(diag(res$mSigma_til))
# pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 10, height= 8)
cols <- c("purple","green", "blue", "red", "purple")
exclude <- c()
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.65
pcntL <- 0.2
pcntT <- 0.65
pcntR <- 0.2
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(1,1),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,4,p)
all_ldens = list()
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dens$y)
ldens[[2]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[3]] <- list(x=xg, y = dlasso(xg,res$a[j], res$b[j], res$c_val))
ldens[[4]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
all_ldens[[j]] = ldens
vacc <- plot_densities(ldens, cols, exclude, gold=1)
mAcc[,j] <- vacc
methods <- c("MCMC", "VB", "LG_Local", "LG_Global")
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
dev.off()
summ <- cbind(round(100*apply(mAcc[,],1,summary),1))
colnames(summ) <- methods
summ
source(here("code/lasso_distribution","lasso_distribution.R"))
source(here("code/lasso_distribution","bivariate_lasso_distribution.R"))
# Convert the list to a long-format dataframe
library(dplyr)
library(tidyr)
library(ggplot2)
for(ldens in all_ldens) {
df <- bind_rows(ldens, .id = "Method")
# Change method name of dataframe
df$Method[df$Method == 1] <- "MCMC"
df$Method[df$Method == 2] <- "MFVB"
df$Method[df$Method == 3] <- "LG_Local"
df$Method[df$Method == 4] <- "LG_Global"
p <- ggplot(df, aes(x = x, y = y, color = Method)) +
geom_line(size = 1) +
labs(title = "Density Plots for Multiple Methods", x = "X", y = "Density", color = "Method") +
theme(plot.title = element_text(hjust = 0.5))
print(p)  # This will plot each ggplot in the loop
}
plot_densities <- function(ldens, cols, exclude, gold, threshold = 0.2) {
vacc <- c()
xlim <- c()
ylim <- c()
## Limit the xlim and ylim of the density plot, if prostate then comment below
# for (k in 1:length(ldens)) {
#  if (!(k %in% exclude)) {
#   # Consider only the x and y values where y > threshold
#  subset_ldens <- subset(ldens[[k]], y > threshold)
# xlim <- range(c(xlim, subset_ldens$x), finite = TRUE)
#  ylim <- range(c(ylim, subset_ldens$y), finite = TRUE)
#}
#}
# xlim =  c(-0.2,0.2)
# ylim = c(0,5)
# plot(NA, type = "n", xlim = xlim, ylim = ylim, xlab = "x", ylab = "density")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x, ldens[[k]]$y, col = cols[k], lwd = 3)
acc <- 1 - 0.5 * trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res$vmu_til
vsigma_LG <- sqrt(diag(res$mSigma_til))
# pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 10, height= 8)
cols <- c("purple","green", "blue", "red", "purple")
exclude <- c()
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.65
pcntL <- 0.2
pcntT <- 0.65
pcntR <- 0.2
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(1,1),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,4,p)
p
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(glmnet)
library(dplyr)
library(tidyr)
library(here)
dat <- read.csv(here("data","prostate.data"), sep="\t")
library(janitor)
dat <- clean_names(dat)
y <- dat$lpsa
x <- dat[,-c(1,10,11)]
dataset_name <- "prostate"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs (2).R"))
u <- 1.0E-4
v <- 1.0E-4
a <- 1.0E-4
b <- 1.0E-4
# Note: For Eye data we should run the Gibbs sampler for the longer iterations, maybe 80,000 iterations for the convergence purposes
nburn <- 5000
nkeep <- 80000
nsamples <- nburn + nkeep
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
set.seed(113)
ti_MCMC <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})[3]
set.seed(1333)
res_gibbs1 <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
set.seed(223)
res_gibbs2 <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
# Gelman_Rubin R hat
library(coda)
inds <- 1:p
GR_beta <- vector('list', length(inds))
for(i in inds){
GR_beta[[i]] <- gelman.diag(mcmc.list(mcmc(res_gibbs$mBeta[-(1:nburn),i]),mcmc(res_gibbs1$mBeta[-(1:nburn),i]),mcmc(res_gibbs2$mBeta[-(1:nburn),i])))
}
for(i in 1:p){
if(GR_beta[[i]]$psrf[1,1]>1.1){
print(i)}
}
# nburn =140000
GR_sig <- gelman.diag(mcmc.list(mcmc(res_gibbs$vsigma2[-(1:nburn)]),mcmc(res_gibbs1$vsigma2[-(1:nburn)]),mcmc(res_gibbs2$vsigma2[-(1:nburn)])))
GR_lam <- gelman.diag(mcmc.list(mcmc(res_gibbs$vlambda2[-(1:nburn)]),mcmc(res_gibbs1$vlambda2[-(1:nburn)]),mcmc(res_gibbs2$vlambda2[-(1:nburn)])))
lambda2 <- mean( res_gibbs$vlambda2 )
lambda <- sqrt(lambda2)
lambda2 <- quantile(res_gibbs$vlambda2, probs=0.999)
lambda <- sqrt(lambda2)
lambda
plot(density(res_gibbs$vlambda2))
source(here("code","bayesian_em_lasso.R"))
time_bem <- system.time({
res_bem <-
bayesian_lasso_em_truncate(vy,
mX,
lambda = lambda, a, b,
vbeta_init = rep(0,p),
sigma2_init = 1,
VERBOSE=FALSE, CALC_SE=FALSE)
})
set.seed(323)
# mX = mX[,-8]   # Use it just for body fat
# p=p-1         # Use it just for body fat
res_lm <- lm(vy~-1+mX)
vbeta_lm <- matrix(res_lm$coef,p,1)
sigma2_lm <- sum((vy - mX%*%vbeta_lm)^2)/n
lambda_glmnet <- 2*n*lambda*sqrt(res_bem$sigma2)
lasso_mod = glmnet(mX,
vy,
alpha = 1,
lambda = lambda_glmnet) # Fit lasso model on training data
sigma2_lm <- sum((vy - mX%*%lasso_mod$beta)^2)/n
source(here("code","bayesian_lasso_gibbs (2).R"))
nburn <- 5000
nkeep <- 50000
nsamples <- nburn + nkeep
lambda_prior <- lambda
library(profvis)
#profvis({
time_gibbs2 <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})[3]
time_gibbs2
library(posterior)
ess1 <- c()
for (j in 1:ncol(res_gibbs$mBeta)) {
ess1[j] <- ess_basic(res_gibbs$mBeta[-c(1:nburn),j])
}
ess1[j+1] <- ess_basic(res_gibbs$vsigma2[-c(1:nburn)])
cbind(ess1)
source(here("code","bayesian_lasso_mfvb.R"))
set.seed(113)
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
#nsamples <- 150000
ti_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda_prior, sigma2_hat=sigma2_lm, a, b, maxiter=nsamples,                                                               tol=1.0E-6)
})[3]
ti_mfvb
source("univariate_local_global.R")
set.seed(113)
lambda = exp(lgamma(res_mfvb$u_til+0.5) - lgamma(res_mfvb$u_til) - 0.5*log(res_mfvb$v_til))
if(p<n){
ti_LGU <- system.time({
res <- univariate_local_global(vy, mX, lambda,
vmu_init=res_mfvb$vmu_til,
mSigma_init=res_mfvb$mSigma_til,
a_til=res_mfvb$a_til,
b_til=res_mfvb$b_til)
})[3]
}else{
ti_LGU <- system.time({
res <- univariate_local_global(vy, mX, lambda,
vmu_init=res_mfvb$vmu_til,
mSigma_init=res_mfvb$vsigma2_til,
a_til=res_mfvb$a_til,
b_til=res_mfvb$b_til)
})[3]
}
ti_LGU
source("bivariate_local_global.R")
set.seed(333)
lambda = exp(lgamma(res_mfvb$u_til+0.5) - lgamma(res_mfvb$u_til) - 0.5*log(res_mfvb$v_til))
ti_LGB <- system.time({
res_bv <- bivariate_local_global(vy, mX, lambda,
vmu_init=res$vmu_til,
mSigma_init=res$mSigma_til,
a_til=res_mfvb$a_til,
b_til=res_mfvb$b_til,
damp=0.005)
})[3]
ti_LGB
save.image(here("../results",paste("results",dataset_name,".Rdata",sep="")))
#load(here("results",paste("results",dataset_name,".Rdata",sep="")))
plot_densities <- function(ldens, cols, exclude, gold, threshold = 0.2) {
vacc <- c()
xlim <- c()
ylim <- c()
## Limit the xlim and ylim of the density plot, if prostate then comment below
# for (k in 1:length(ldens)) {
#  if (!(k %in% exclude)) {
#   # Consider only the x and y values where y > threshold
#  subset_ldens <- subset(ldens[[k]], y > threshold)
# xlim <- range(c(xlim, subset_ldens$x), finite = TRUE)
#  ylim <- range(c(ylim, subset_ldens$y), finite = TRUE)
#}
#}
# xlim =  c(-0.2,0.2)
# ylim = c(0,5)
# plot(NA, type = "n", xlim = xlim, ylim = ylim, xlab = "x", ylab = "density")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x, ldens[[k]]$y, col = cols[k], lwd = 3)
acc <- 1 - 0.5 * trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res$vmu_til
vsigma_LG <- sqrt(diag(res$mSigma_til))
# pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 10, height= 8)
cols <- c("purple","green", "blue", "red", "purple")
exclude <- c()
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.65
pcntL <- 0.2
pcntT <- 0.65
pcntR <- 0.2
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(1,1),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,4,p)
all_ldens = list()
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dens$y)
ldens[[2]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[3]] <- list(x=xg, y = dlasso(xg,res$a[j], res$b[j], res$c_val))
ldens[[4]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
all_ldens[[j]] = ldens
vacc <- plot_densities(ldens, cols, exclude, gold=1)
mAcc[,j] <- vacc
methods <- c("MCMC", "VB", "LG_Local", "LG_Global")
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
