mu2 <- -(b + c)/a
sigma2 <- 1/a
sigma <- sqrt(sigma2)
Z <- sigma*(mills_ratio(mu1/sigma) + mills_ratio(mu2/sigma))
return(Z)
}
zlasso(0,100000,20)
mills_ratio <- function(x) {
val <- 1/zeta(1,x)
return(val)
}
zlasso(0,100000,20)
zlasso(1,100000,20)
zlasso(100,100000,20)
zlasso(100,10000,20)
zlasso(100,1000,20)
zlasso(100,1000,2)
zlasso(1,1000,2)
zlasso(1,100,2)
zlasso(1,10,2)
norm_const_lasso(1,100,2)
norm_const_lasso(10,100,2)
norm_const_lasso(10,100,20)
?zeta
if(1==1)
print(0)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
if(mlocal_var != matrix(mSigma_adjust[j,j]))
{
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
}
# Damping
mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
if(mlocal_var != matrix(mSigma_adjust[j,j]))
{
print(mlocal_var)
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
}
# Damping
mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
print(matrix(solve(mSigma_adjust[j,j])))
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
if(mlocal_var != matrix(mSigma_adjust[j,j]))
{
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
}
# Damping
mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
print(matrix(solve(mSigma_adjust[j,j])))
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
if(mlocal_var != matrix(mSigma_adjust[j,j]))
{
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
}
# Damping
# mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
# Damping
# mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
source(here("code","lasso_distribution","myLasso.R"))
## INPUT: y, mX, lambda, param
## OUTPUT: Global adjust mean, Global adjust covariance
## If there is a scalar output, change it to 1*1 matrix output, otherwise remain same
local_global_algorithm_1 <- function(vy, mX, lambda, params)
{
## Initialization
MAXITER <- 500
TOL <- 1.0E-8
n <- nrow(mX)
p <- ncol(mX)
XTX = t(mX)%*%mX
rho = 0.8
## Initial Global Mean and Global Covariance From MFVB
vmu_adjust = params$vmu_til
mSigma_adjust = params$mSigma_til
# Later will be changed
a_til = params$a_til
b_til = params$b_til
c = lambda * gamma(a_til+0.5)/(gamma(a_til)*sqrt(b_til))
# Record the local parameter
va = c()
vb = c()
vZ = c()
# Initial value Local parameters
vtheta <- c(vmu_adjust)
for (ITER in 1:MAXITER)
{
## Local Update
for (j in 1:p)
{
# Local Update
mt = matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j]))
vs = matrix(vmu_adjust[-j]) - mt %*% matrix(vmu_adjust[j])
## Update local parameter
a = a_til/b_til*(matrix(XTX[j,j]) + t(XTX[j,-j]%*%mt))
b = a_til/b_til*t(mX[,j])%*%(vy-mX[,-j]%*%vs)
print(c(a,b,c))
## Calculate Local mean and variance
vlocal_mean = elasso(a,b,c)
mlocal_var = vlasso(a,b,c)
# Record local parameter
va[j] = a
vb[j] = b
vZ[j] = calculate_uni_lasso_param(a,b,c)$Z
# Global Update
## Update Mean
vmu_adjust[j] = vlocal_mean
vmu_adjust[-j] = matrix(vmu_adjust[-j]) + matrix(mSigma_adjust[-j,j]) %*% matrix(solve(mSigma_adjust[j,j])) %*% matrix(vlocal_mean - vmu_adjust[j])
##  Update Covariance
j_len = length(vlocal_mean)
mSigma_jj_inv = matrix(solve(mSigma_adjust[j,j]),j_len,j_len)
# Store sigma value from previous iteration
mSigma_old = mSigma_adjust
mSigma_adjust[j,j] = mlocal_var
mSigma_adjust[j,-j] = mlocal_var %*% mSigma_jj_inv %*%  t(matrix(mSigma_adjust[j,-j]))
mSigma_adjust[-j,j] = t(mSigma_adjust[j,-j])
mSigma_adjust[-j,-j] = matrix(mSigma_adjust[-j,-j],p-j_len,p-j_len) + matrix(mSigma_adjust[-j,j]) %*% mSigma_jj_inv %*% (mlocal_var - matrix(mSigma_adjust[j,j]))  %*%mSigma_jj_inv %*% t(matrix(mSigma_adjust[j,-j]))
# Damping
# mSigma_adjust = rho* mSigma_adjust + (1-rho)*mSigma_old
}
# Update Theta
vtheta_old <- vtheta
vtheta <- c(vmu_adjust)
## Check stopping criterion
err <- max(abs(vtheta - vtheta_old))
cat("ITER=",ITER,"err=",err,"\n")
if (err < TOL) {
break;
}
}
# Return Local and Global parameter
return(list("mu" = vmu_adjust,"Sigma" = mSigma_adjust, "a" = va,"b" = vb,"c"= c ,"Z" = vZ))
}
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(glmnet)
library(dplyr)
library(tidyr)
library(here)
Hitters = na.omit(Hitters)
str(Hitters)
x = model.matrix(Salary~., Hitters)[,-1] # trim off the first column
# leaving only the predictors
y = Hitters %>%
select(Salary) %>%
unlist() %>%
as.numeric()
summary(Hitters)
dataset_name <- "Hitters"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs.R"))
