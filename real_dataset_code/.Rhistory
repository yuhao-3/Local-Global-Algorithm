source(here("code","local_global_algorithms.R"))
time_LG <- system.time({
res_LG = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
cat("BEM running time = ",time_bem[3],"s")
cat("\nMCMC running time = ",time_gibbs2[3],"s")
cat("\nMCVB running time = ",time_mcvb[3],"s")
cat("BEM running time = ",time_bem[3],"s")
cat("\nMCMC running time = ",time_gibbs2[3],"s")
cat("\nMFVB running time = ",time_mfvb[3],"s")
cat("\nLG running time =",time_LG[3],"s")
plot_densities <- function(ldens, cols, exclude, gold)
{
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k%in%exclude)) {
xlim <- range(c(xlim,ldens[[k]]$x), finite = TRUE)
ylim <- range(c(ylim,ldens[[k]]$y), finite = TRUE)
}
}
plot(NA,type="n", xlim=xlim, ylim=ylim, xlab="", ylab="")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x,ldens[[k]]$y, col=cols[k], lwd=2)
acc <- 1 - 0.5*trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_bem <- res_bem$vbeta
vsigma_bem <- res_bem$vse[-(p+1)]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res_LG$vmu_til
vsigma_LG <- sqrt(diag(res_LG$mSigma_til))
va = res_LG$a
vb = res_LG$b
cc = res_LG$c
pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 12, height=8)
cols <- c("red", "blue", "green", "orange","purple", "black","darkgray")
exclude <- c(1,2)
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.3
pcntL <- 0.3
pcntT <- 0.3
pcntR <- 0.3
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(3,3),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,6,p)
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dnorm(xg,vmu_bem[j], vsigma_bem[j]))
ldens[[2]] <- list(x=xg,y=dens$y)
ldens[[3]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[4]] <-
vb_phc_grad(
xg,
res_mfvb$a_til,
res_mfvb$b_til,
res_mfvb$vmu_til,
res_mfvb$mSigma_til,
XTX,
XTy,
lambda,
j
)
ldens[[5]] <- list(x=xg, y = dlasso(xg,va[j],vb[j],cc))
ldens[[6]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
vacc <- plot_densities(ldens, cols, exclude, gold=2)
mAcc[,j] <- vacc
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global")
if (j==1) {
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
}
dev.off()
summ <- cbind(round(100*apply(mAcc[-1,],1,summary),1))
colnames(summ) <- methods[-1]
summ
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
p
library(tidyr)
crossing(var1 = 0:1, var2 = 0:1, var3 = 0:1)
library(tidyr)
crossing(var1 = 0:p, var2 = 0:p)
pair = crossing(var1 = 0:2, var2 = 0:2)
pair = crossing(var1 = 1:2, var2 = 1:2)
pair
library(gtools)
install.packages("gtools")
library(gtools)
gtools::permutations(n,k)
library(gtools)
gtools::permutations(2,1)
library(gtools)
gtools::permutations(5,1)
library(gtools)
gtools::permutations(5,2)
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
plot_densities <- function(ldens, cols, exclude, gold)
{
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k%in%exclude)) {
xlim <- range(c(xlim,ldens[[k]]$x), finite = TRUE)
ylim <- range(c(ylim,ldens[[k]]$y), finite = TRUE)
}
}
plot(NA,type="n", xlim=xlim, ylim=ylim, xlab="", ylab="")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x,ldens[[k]]$y, col=cols[k], lwd=2)
acc <- 1 - 0.5*trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_bem <- res_bem$vbeta
vsigma_bem <- res_bem$vse[-(p+1)]
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res_LG1$vmu_til
vsigma_LG <- sqrt(diag(res_LG1$mSigma_til))
va = res_LG1$a
vb = res_LG1$b
cc = res_LG1$c
pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 12, height=8)
cols <- c("red", "blue", "green", "orange","purple", "black","darkgray")
exclude <- c(1,2)
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.3
pcntL <- 0.3
pcntT <- 0.3
pcntR <- 0.3
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(3,3),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,6,p)
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dnorm(xg,vmu_bem[j], vsigma_bem[j]))
ldens[[2]] <- list(x=xg,y=dens$y)
ldens[[3]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[4]] <-
vb_phc_grad(
xg,
res_mfvb$a_til,
res_mfvb$b_til,
res_mfvb$vmu_til,
res_mfvb$mSigma_til,
XTX,
XTy,
lambda,
j
)
ldens[[5]] <- list(x=xg, y = dlasso(xg,va[j],vb[j],cc))
ldens[[6]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
vacc <- plot_densities(ldens, cols, exclude, gold=2)
mAcc[,j] <- vacc
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global")
if (j==1) {
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
}
dev.off()
summ <- cbind(round(100*apply(mAcc[-1,],1,summary),1))
colnames(summ) <- methods[-1]
summ
gtools::permutations(5,2)
gtools::permutations(2,5)
unique(pair)
unique(pairs)
unique(gtools::permutations(5,2))
set(unique(gtools::permutations(5,2)))
set(gtools::permutations(5,2))
comb <- expand.grid(x, x)
comb
comb <- expand.grid(c(1,2),c(1,2))
comb
t(combn(c(1,2),c(1,2)))
t(combn(c(1,2),2))
t(combn(c(1,2),c(1,3)))
t(combn(c(1,2),c(1,2)))
comb(unique(c(1,p)),2)
combn(unique(c(1,p)),2)
combn(unique(c(1,2)),2)
combn(unique(c(1,3)),2)
combn(unique(c(1:3)),2)
combn(unique(c(1:4)),2)
t(combn(unique(c(1:p)),2))
length(t(combn(unique(c(1:3)),2)))
length(t(combn(unique(c(1:p)),2)))
dim(t(combn(unique(c(1:p)),2)))
dim(t(combn(unique(c(1:p)),2)))[1]
source(here("code","lasso_distribution","myLasso.R"))
source(here("code","lasso_distribution","Multi-Lasso.R"))
source(here("code","local_global_algorithms.R"))
dim(t(combn(unique(c(1:p)),2)))[1]
t(combn(unique(c(1:p)),2))
t(combn(unique(c(1:p)),2))[1]
t(combn(unique(c(1:p)),2))[1,1]
t(combn(unique(c(1:p)),2))[1,2]
t(combn(unique(c(1:p)),2))[1,3]
t(combn(unique(c(1:p)),2))[2,1]
p = c()
p[1] = matrix(c(2,3,4,5),2,2)
p= list()
p[[1]] = matrix(c(2,3,4,5),2,2)
p
p[1] = matrix(c(2,3,4,5),2,2)
p[[2]] = matrix(c(2,3,4,5),2,2)
p
p[[1]] = matrix(c(2,3,4,5),2,2)
p[[2]] = matrix(c(2,3,4,5),2,2)
p
p[[c(1,2)]] = matrix(c(2,3,4,5),2,2)
time_LG2 <- system.time({
res_LG2 = local_global_algorithm_2(vy, mX, lambda, res_mfvb)
})
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
time_LG2 <- system.time({
res_LG2 = local_global_algorithm_2(vy, mX, lambda, res_mfvb)
})
cat("BEM running time = ",time_bem[3],"s")
cat("\nMCMC running time = ",time_gibbs2[3],"s")
cat("\nMFVB running time = ",time_mfvb[3],"s")
cat("\nLG1 running time =",time_LG1[3],"s")
cat("\nLG 2running time =",time_LG2[3],"s")
plot_densities <- function(ldens, cols, exclude, gold)
{
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k%in%exclude)) {
xlim <- range(c(xlim,ldens[[k]]$x), finite = TRUE)
ylim <- range(c(ylim,ldens[[k]]$y), finite = TRUE)
}
}
plot(NA,type="n", xlim=xlim, ylim=ylim, xlab="", ylab="")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x,ldens[[k]]$y, col=cols[k], lwd=2)
acc <- 1 - 0.5*trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_bem <- res_bem$vbeta
vsigma_bem <- res_bem$vse[-(p+1)]
p
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(glmnet)
library(dplyr)
library(tidyr)
library(here)
Hitters = na.omit(Hitters)
str(Hitters)
x = model.matrix(Salary~., Hitters)[,-1] # trim off the first column
# leaving only the predictors
y = Hitters %>%
select(Salary) %>%
unlist() %>%
as.numeric()
summary(Hitters)
dataset_name <- "Hitters"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 5000
nsamples <- nburn + nkeep
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
lambda2 <- mean( res_gibbs$vlambda2 )
lambda <- sqrt(lambda2)
lambda2 <- quantile(res_gibbs$vlambda2, probs=0.5)
lambda <- sqrt(lambda2)
lambda
plot(density(res_gibbs$vlambda2))
source(here("code","bayesian_em_lasso.R"))
time_bem <- system.time({
res_bem <-
bayesian_lasso_em(vy,
mX,
lambda = lambda,
vbeta_init = rep(0,p),
sigma2_init = 1,
VERBOSE=FALSE)
})
res_lm <- lm(vy~-1+mX)
vbeta_lm <- matrix(res_lm$coef,p,1)
sigma2_lm <- sum((vy - mX%*%vbeta_lm)^2)/n
lambda_glmnet <- 2*n*lambda*sqrt(res_bem$sigma2)
lasso_mod = glmnet(mX,
vy,
alpha = 1,
lambda = lambda_glmnet) # Fit lasso model on training data
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 1000000
nsamples <- nburn + nkeep
lambda_prior <- lambda
library(profvis)
if(file.exists(paste("res_gibbs",dataset_name,".Rdata",sep="")))
{
load(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}else
{
time_gibbs2 <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})
save.image(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(glmnet)
library(dplyr)
library(tidyr)
library(here)
Hitters = na.omit(Hitters)
str(Hitters)
x = model.matrix(Salary~., Hitters)[,-1] # trim off the first column
# leaving only the predictors
y = Hitters %>%
select(Salary) %>%
unlist() %>%
as.numeric()
summary(Hitters)
dataset_name <- "Hitters"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 5000
nsamples <- nburn + nkeep
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
lambda2 <- mean( res_gibbs$vlambda2 )
lambda <- sqrt(lambda2)
lambda2 <- quantile(res_gibbs$vlambda2, probs=0.5)
lambda <- sqrt(lambda2)
lambda
plot(density(res_gibbs$vlambda2))
source(here("code","bayesian_em_lasso.R"))
time_bem <- system.time({
res_bem <-
bayesian_lasso_em(vy,
mX,
lambda = lambda,
vbeta_init = rep(0,p),
sigma2_init = 1,
VERBOSE=FALSE)
})
res_lm <- lm(vy~-1+mX)
vbeta_lm <- matrix(res_lm$coef,p,1)
sigma2_lm <- sum((vy - mX%*%vbeta_lm)^2)/n
lambda_glmnet <- 2*n*lambda*sqrt(res_bem$sigma2)
lasso_mod = glmnet(mX,
vy,
alpha = 1,
lambda = lambda_glmnet) # Fit lasso model on training data
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 1000000
nsamples <- nburn + nkeep
lambda_prior <- lambda
library(profvis)
if(file.exists(paste("res_gibbs",dataset_name,".Rdata",sep="")))
{
load(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}else
{
time_gibbs2 <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})
save.image(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}
source(here("code","bayesian_lasso_mfvb.R"))
time_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda, 1)
})
source(here("code","lasso_distribution","dlasso.R"))
trapint <- function(xgrid, fgrid)
{
ng <- length(xgrid)
xvec <- xgrid[2:ng] - xgrid[1:(ng - 1)]
fvec <- fgrid[1:(ng - 1)] + fgrid[2:ng]
integ <- sum(xvec * fvec)/2
return(integ)
}
vb_phc <- function(mu, sigma, N, nsd, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
x <- seq(mu - nsd*sigma, mu + nsd*sigma, length=N)
y <- 0*x
lambda2 <- lambda*lambda
mQ <- solve(XTX + lambda2*res_mfvb$vd, tol=1.0E-99)
vmu <- mQ%*%XTy
m  <- XTy[j] - XTX[j,-j]%*%vmu[-j]
s2 <- XTX[j,-j]%*%mQ[-j,-j]%*%XTX[-j,j]
s  <- sqrt(s2)
m  <- as.vector(m)
s2 <- as.vector(s2)
s  <- as.vector(s)
K <- 5000
mBeta <- t(rmvnorm(K, vmu_til, sigma=mSigma_til))
vB <- (XTy[j] - XTX[j,-j]%*%mBeta[-j,])
for (i in 1:K) {
sigma2 <- rinvgamma(1, shape=a_til, rate=b_til)
sigma  <- sqrt(sigma2)
A <-  XTX[j,j]/sigma2
B <-  vB[i]/sigma2
B <- as.vector(B)
C <- -lambda/sigma
y <- y + dlasso(x,A,B,C)
}
y <- y/K
return(list(x=x,y=y))
}
vb_phc_grad <- function(x, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- (a_til/b_til)*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- (a_til/b_til)*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*exp(lgamma(a_til + 1/2) - lgamma(a_til) - 0.5*log(b_til))
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
cat("c0=",c0,"\n")
cat("c1=",c1,"\n")
cat("c2=",c2,"\n")
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
vb_phc_grad2 <- function(x, E_sigma2inv, E_sigmainv, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- E_sigma2inv*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- E_sigma2inv*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*E_sigmainv
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
source(here("code","lasso_distribution","myLasso.R"))
source(here("code","lasso_distribution","Multi-Lasso.R"))
source(here("code","local_global_algorithms.R"))
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
time_LG2 <- system.time({
res_LG2 = local_global_algorithm_2(vy, mX, lambda, res_mfvb)
})
