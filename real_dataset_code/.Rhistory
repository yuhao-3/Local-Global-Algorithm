"vparks",
"tvenv",
"conservation",
"sex",
"age",
"schooling",
"major")
varnames <- colnames(x)
dataset_name <- "Kakadu.csv"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 5000
nsamples <- nburn + nkeep
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
lambda2 <- mean(res_gibbs$vlambda2 )
lambda <- sqrt(lambda2)
lambda2 <- quantile(res_gibbs$vlambda2, probs=0.5)
lambda <- sqrt(lambda2)
lambda
plot(density(res_gibbs$vlambda2))
source(here("code","bayesian_em_lasso.R"))
time_bem <- system.time({
res_bem <-
bayesian_lasso_em(vy,
mX,
lambda = lambda,
vbeta_init = rep(0,p),
sigma2_init = 1,
VERBOSE=FALSE)
})
res_lm <- lm(vy~-1+mX)
vbeta_lm <- matrix(res_lm$coef,p,1)
sigma2_lm <- sum((vy - mX%*%vbeta_lm)^2)/n
lambda_glmnet <- 2*n*lambda*sqrt(res_bem$sigma2)
lasso_mod = glmnet(mX,
vy,
alpha = 1,
lambda = lambda_glmnet) # Fit lasso model on training data
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 1000000
nsamples <- nburn + nkeep
lambda_prior <- lambda
library(profvis)
if(file.exists(paste("res_gibbs",dataset_name,".Rdata",sep="")))
{
load(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}else
{
time_gibbs2 <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})
save.image(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}
source(here("code","bayesian_lasso_mfvb.R"))
time_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda, 1)
})
source(here("code","lasso_distribution","dlasso.R"))
trapint <- function(xgrid, fgrid)
{
ng <- length(xgrid)
xvec <- xgrid[2:ng] - xgrid[1:(ng - 1)]
fvec <- fgrid[1:(ng - 1)] + fgrid[2:ng]
integ <- sum(xvec * fvec)/2
return(integ)
}
vb_phc <- function(mu, sigma, N, nsd, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
x <- seq(mu - nsd*sigma, mu + nsd*sigma, length=N)
y <- 0*x
lambda2 <- lambda*lambda
mQ <- solve(XTX + lambda2*res_mfvb$vd, tol=1.0E-99)
vmu <- mQ%*%XTy
m  <- XTy[j] - XTX[j,-j]%*%vmu[-j]
s2 <- XTX[j,-j]%*%mQ[-j,-j]%*%XTX[-j,j]
s  <- sqrt(s2)
m  <- as.vector(m)
s2 <- as.vector(s2)
s  <- as.vector(s)
K <- 5000
mBeta <- t(rmvnorm(K, vmu_til, sigma=mSigma_til))
vB <- (XTy[j] - XTX[j,-j]%*%mBeta[-j,])
for (i in 1:K) {
sigma2 <- rinvgamma(1, shape=a_til, rate=b_til)
sigma  <- sqrt(sigma2)
A <-  XTX[j,j]/sigma2
B <-  vB[i]/sigma2
B <- as.vector(B)
C <- -lambda/sigma
y <- y + dlasso(x,A,B,C)
}
y <- y/K
return(list(x=x,y=y))
}
vb_phc_grad <- function(x, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- (a_til/b_til)*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- (a_til/b_til)*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*exp(lgamma(a_til + 1/2) - lgamma(a_til) - 0.5*log(b_til))
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
cat("c0=",c0,"\n")
cat("c1=",c1,"\n")
cat("c2=",c2,"\n")
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
vb_phc_grad2 <- function(x, E_sigma2inv, E_sigmainv, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- E_sigma2inv*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- E_sigma2inv*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*E_sigmainv
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
source(here("code","local_global_algorithms.R"))
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
source(here("code","local_global_algorithms.R"))
if(file.exists(paste("res_LG2",dataset_name,".Rdata",sep="")))
{
load(paste("res_LG2",dataset_name,".Rdata",sep=""))
}else
{
time_LG2 <- system.time({
res_LG2 = local_global_algorithm_2(vy, mX, lambda, res_mfvb)
})
save.image(paste("res_LG2",dataset_name,".Rdata",sep=""))
}
cat("BEM running time = ",time_bem[3],"s")
cat("\nMCMC running time = ",time_gibbs2[3],"s")
cat("\nMFVB running time = ",time_mfvb[3],"s")
cat("\nLG1 running time =",time_LG1[3],"s")
cat("\nLG2 running time =",time_LG2[3],"s")
cat("\nLG2 new running time =",time_LG2_new[3],"s")
source(here("code/lasso_distribution","Multi-Lasso.R"))
plot_densities <- function(ldens, cols, exclude, gold)
{
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k%in%exclude)) {
xlim <- range(c(xlim,ldens[[k]]$x), finite = TRUE)
ylim <- range(c(ylim,ldens[[k]]$y), finite = TRUE)
}
}
plot(NA,type="n", xlim=xlim, ylim=ylim, xlab="", ylab="")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x,ldens[[k]]$y, col=cols[k], lwd=2)
acc <- 1 - 0.5*trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_bem <- res_bem$vbeta
vsigma_bem <- res_bem$vse[-(p+1)]
# Parameter for LG1
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res_LG1$vmu_til
vsigma_LG <- sqrt(diag(res_LG1$mSigma_til))
va = res_LG1$a
vb = res_LG1$b
cc = res_LG1$c
# Paraemter for LG2
# vmu_LG2 <- res_LG2$vmu_til
# vsigma_LG2 <- sqrt(diag(res_LG2$mSigma_til))
# vA = res_LG2$A
# vb2 = res_LG2$b
# cc2 = res_LG2$c
# Paraemter for LG2 new
# vmu_LG2 <- res_LG2_new$vmu_til
# vsigma_LG2 <- sqrt(diag(res_LG2_new$mSigma_til))
#
# vA = res_LG2_new$A
# vb2 = res_LG2_new$b
# cc2 = res_LG2_new$c
pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 12, height=8)
cols <- c("red", "blue", "green", "orange","purple", "black","darkgray")
exclude <- c(1,2)
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.3
pcntL <- 0.3
pcntT <- 0.3
pcntR <- 0.3
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(3,3),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,6,p)
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dnorm(xg,vmu_bem[j], vsigma_bem[j]))
ldens[[2]] <- list(x=xg,y=dens$y)
ldens[[3]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[4]] <-
vb_phc_grad(
xg,
res_mfvb$a_til,
res_mfvb$b_til,
res_mfvb$vmu_til,
res_mfvb$mSigma_til,
XTX,
XTy,
lambda,
j
)
ldens[[5]] <- list(x=xg, y = dlasso(xg,va[j],vb[j],cc))
ldens[[6]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
# ldens[[7]] <- list(x=xg, y = dmmlasso1(xg,vA[[j]],vb2[[j]],cc2))
# ldens[[8]] <- list(x=xg, y = dmmlasso2(xg,vA[[j]],vb2[[j]],cc2))
# ldens[[9]] <- list(x=xg, y = dnorm(xg,vmu_LG2[j], vsigma_LG2[j]))
vacc <- plot_densities(ldens, cols, exclude, gold=2)
mAcc[,j] <- vacc
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global","LG2_Local1","LG2_Local2","LG2_Global")
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global")
if (j==1) {
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
}
dev.off()
summ <- cbind(round(100*apply(mAcc[-1,],1,summary),1))
colnames(summ) <- methods[-1]
summ
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(glmnet)
library(dplyr)
library(tidyr)
library(here)
dat <- read.csv(here("data","bodyfat.txt"), sep="\t")
library(janitor)
dat <- clean_names(dat)
y <- dat$pct_bf
x <- dat[,-2]
dataset_name <- "bodyfat"
vy <- (y - mean(y))/sd(y)
mX <- scale(x, center = TRUE, scale = TRUE)
n <- nrow(mX)
p <- ncol(mX)
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 5000
nsamples <- nburn + nkeep
lambda_prior <- list(lambda_start=1, prior="gamma",u=1,v=1)
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
lambda2 <- mean(res_gibbs$vlambda2 )
lambda <- sqrt(lambda2)
lambda2 <- quantile(res_gibbs$vlambda2, probs=0.5)
lambda <- sqrt(lambda2)
lambda
plot(density(res_gibbs$vlambda2))
source(here("code","bayesian_em_lasso.R"))
time_bem <- system.time({
res_bem <-
bayesian_lasso_em(vy,
mX,
lambda = lambda,
vbeta_init = rep(0,p),
sigma2_init = 1,
VERBOSE=FALSE)
})
res_lm <- lm(vy~-1+mX)
vbeta_lm <- matrix(res_lm$coef,p,1)
sigma2_lm <- sum((vy - mX%*%vbeta_lm)^2)/n
lambda_glmnet <- 2*n*lambda*sqrt(res_bem$sigma2)
lasso_mod = glmnet(mX,
vy,
alpha = 1,
lambda = lambda_glmnet) # Fit lasso model on training data
source(here("code","bayesian_lasso_gibbs.R"))
nburn <- 5000
nkeep <- 1000000
nsamples <- nburn + nkeep
lambda_prior <- lambda
library(profvis)
if(file.exists(paste("res_gibbs",dataset_name,".Rdata",sep="")))
{
load(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}else
{
time_gibbs2 <- system.time({
res_gibbs <- bayesian_lasso_gibbs(vy, mX, lambda=lambda_prior, nsamples=nsamples)
})
save.image(paste("res_gibbs",dataset_name,".Rdata",sep=""))
}
source(here("code","bayesian_lasso_mfvb.R"))
time_mfvb <- system.time({
res_mfvb <- bayesian_lasso_mfvb(vy, mX, lambda, 1)
})
source(here("code","lasso_distribution","dlasso.R"))
trapint <- function(xgrid, fgrid)
{
ng <- length(xgrid)
xvec <- xgrid[2:ng] - xgrid[1:(ng - 1)]
fvec <- fgrid[1:(ng - 1)] + fgrid[2:ng]
integ <- sum(xvec * fvec)/2
return(integ)
}
vb_phc <- function(mu, sigma, N, nsd, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
x <- seq(mu - nsd*sigma, mu + nsd*sigma, length=N)
y <- 0*x
lambda2 <- lambda*lambda
mQ <- solve(XTX + lambda2*res_mfvb$vd, tol=1.0E-99)
vmu <- mQ%*%XTy
m  <- XTy[j] - XTX[j,-j]%*%vmu[-j]
s2 <- XTX[j,-j]%*%mQ[-j,-j]%*%XTX[-j,j]
s  <- sqrt(s2)
m  <- as.vector(m)
s2 <- as.vector(s2)
s  <- as.vector(s)
K <- 5000
mBeta <- t(rmvnorm(K, vmu_til, sigma=mSigma_til))
vB <- (XTy[j] - XTX[j,-j]%*%mBeta[-j,])
for (i in 1:K) {
sigma2 <- rinvgamma(1, shape=a_til, rate=b_til)
sigma  <- sqrt(sigma2)
A <-  XTX[j,j]/sigma2
B <-  vB[i]/sigma2
B <- as.vector(B)
C <- -lambda/sigma
y <- y + dlasso(x,A,B,C)
}
y <- y/K
return(list(x=x,y=y))
}
vb_phc_grad <- function(x, a_til, b_til, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- (a_til/b_til)*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- (a_til/b_til)*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*exp(lgamma(a_til + 1/2) - lgamma(a_til) - 0.5*log(b_til))
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
cat("c0=",c0,"\n")
cat("c1=",c1,"\n")
cat("c2=",c2,"\n")
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
vb_phc_grad2 <- function(x, E_sigma2inv, E_sigmainv, vmu_til, mSigma_til, XTX, XTy, lambda, j )
{
vs <- vmu_til[-j] - mSigma_til[-j,j]*vmu_til[j]/mSigma_til[j,j]
vt <- mSigma_til[-j,j]/mSigma_til[j,j]
c0 <- E_sigma2inv*(XTy[j] - XTX[j,-j]%*%vs)
c1 <- E_sigma2inv*(XTX[j,j] + XTX[j,-j]%*%vt)
c2 <- lambda*E_sigmainv
c0 <- as.vector(c0)
c1 <- as.vector(c1)
c2 <- as.vector(c2)
y <- d_oldlasso(x,c1,c0,-c2)
return(list(x=x,y=y))
}
source(here("code","local_global_algorithms.R"))
time_LG1 <- system.time({
res_LG1 = local_global_algorithm_1(vy, mX, lambda, res_mfvb)
})
cat("BEM running time = ",time_bem[3],"s")
cat("\nMCMC running time = ",time_gibbs2[3],"s")
cat("\nMFVB running time = ",time_mfvb[3],"s")
cat("\nLG1 running time =",time_LG1[3],"s")
cat("\nLG2 running time =",time_LG2[3],"s")
# cat("\nLG2 new running time =",time_LG2_new[3],"s")
# save.image(here("results",paste("results",dataset_name,".Rdata",sep="")))
#load(here("results",paste("results",dataset_name,".Rdata",sep="")))
source(here("code/lasso_distribution","Multi-Lasso.R"))
plot_densities <- function(ldens, cols, exclude, gold)
{
vacc <- c()
xlim <- c()
ylim <- c()
for (k in 1:length(ldens)) {
if (!(k%in%exclude)) {
xlim <- range(c(xlim,ldens[[k]]$x), finite = TRUE)
ylim <- range(c(ylim,ldens[[k]]$y), finite = TRUE)
}
}
plot(NA,type="n", xlim=xlim, ylim=ylim, xlab="", ylab="")
for (k in 1:length(ldens)) {
lines(ldens[[k]]$x,ldens[[k]]$y, col=cols[k], lwd=2)
acc <- 1 - 0.5*trapint(ldens[[gold]]$x, abs(ldens[[gold]]$y - ldens[[k]]$y))
vacc[k] <- acc
}
return(vacc)
}
N <- 10000
nsd <- 5
vmu_lm <- vbeta_lm
vsigma_lm <- summary(res_lm)$coefficients[,2]
vmu_bem <- res_bem$vbeta
vsigma_bem <- res_bem$vse[-(p+1)]
# Parameter for LG1
vmu_mfvb    <- res_mfvb$vmu_til
vsigma_mfvb <- sqrt(diag(res_mfvb$mSigma_til))
vmu_LG <- res_LG1$vmu_til
vsigma_LG <- sqrt(diag(res_LG1$mSigma_til))
va = res_LG1$a
vb = res_LG1$b
cc = res_LG1$c
# Paraemter for LG2
# vmu_LG2 <- res_LG2$vmu_til
# vsigma_LG2 <- sqrt(diag(res_LG2$mSigma_til))
# vA = res_LG2$A
# vb2 = res_LG2$b
# cc2 = res_LG2$c
# Paraemter for LG2 new
# vmu_LG2 <- res_LG2_new$vmu_til
# vsigma_LG2 <- sqrt(diag(res_LG2_new$mSigma_til))
#
# vA = res_LG2_new$A
# vb2 = res_LG2_new$b
# cc2 = res_LG2_new$c
pdf(here("figures",paste("lasso_densities_",dataset_name,".pdf",sep="")), width= 12, height=8)
cols <- c("red", "blue", "green", "orange","purple", "black","darkgray")
exclude <- c(1,2)
XTX <- t(mX)%*%mX
XTy <- t(mX)%*%vy
mai.dft <- c(1.02,0.82,0.82,0.42) #par("mai") # Defaults
op <- par(mai=mai.dft)
pcntB <- 0.3
pcntL <- 0.3
pcntT <- 0.3
pcntR <- 0.3
mai.new <- c(pcntB,pcntL,pcntT,pcntR) #*c(1.02,0.82,0.82,0.42)
par(mfrow=c(3,3),mai=mai.new)
ranges <- apply(res_gibbs$mBeta[-c(1:nburn),], 2, range)
mAcc <- matrix(0,6,p)
for (j in 1:p) {
#if (!is.nan(vsigma_bem[j])) {
#  L <- min(c(ranges[1,j],qnorm(0.001,vmu_bem[j], vsigma_bem[j])))
#  R <- max(c(ranges[2,j],qnorm(0.999,vmu_bem[j], vsigma_bem[j])))
#} else {
L <- ranges[1,j]
R <- ranges[2,j]
#}
dens <- density(res_gibbs$mBeta[-c(1:nburn),j], from = L, to=R, n=N)
xg <- dens$x
ldens <- list()
ldens[[1]] <- list(x=xg,y=dnorm(xg,vmu_bem[j], vsigma_bem[j]))
ldens[[2]] <- list(x=xg,y=dens$y)
ldens[[3]] <- list(x=xg,y=dnorm(xg,vmu_mfvb[j], vsigma_mfvb[j]))
ldens[[4]] <-
vb_phc_grad(
xg,
res_mfvb$a_til,
res_mfvb$b_til,
res_mfvb$vmu_til,
res_mfvb$mSigma_til,
XTX,
XTy,
lambda,
j
)
ldens[[5]] <- list(x=xg, y = dlasso(xg,va[j],vb[j],cc))
ldens[[6]] <- list(x=xg, y = dnorm(xg,vmu_LG[j], vsigma_LG[j]))
# ldens[[7]] <- list(x=xg, y = dmmlasso1(xg,vA[[j]],vb2[[j]],cc2))
# ldens[[8]] <- list(x=xg, y = dmmlasso2(xg,vA[[j]],vb2[[j]],cc2))
# ldens[[9]] <- list(x=xg, y = dnorm(xg,vmu_LG2[j], vsigma_LG2[j]))
vacc <- plot_densities(ldens, cols, exclude, gold=2)
mAcc[,j] <- vacc
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global","LG2_Local1","LG2_Local2","LG2_Global")
methods <- c("BEM+SE","MCMC", "VB", "VB-PHC","LG_Local","LG_Global")
if (j==1) {
legend("topright",
legend=methods,
text.col=cols[1:7],
border = FALSE)
}
}
dev.off()
summ <- cbind(round(100*apply(mAcc[-1,],1,summary),1))
colnames(summ) <- methods[-1]
summ
save.image(paste("results",dataset_name,".Rdata",sep=""))
load(paste("results",dataset_name,".Rdata",sep=""))
