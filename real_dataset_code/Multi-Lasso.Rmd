---
title: "Multi-Lasso"
author: "Yuhao Li"
date: '2023-02-08'
output: html_document
---


##  Test Multi-variate Lasso distribution(Normalizing const)
```{r}
library(here)
library(pracma)
# library(tmvtnorm)
library(cubature)
source(here("code","lasso_distribution","Multi-Lasso.R")) 

A = matrix(c(2,1,1,3),2,2)
b = matrix(c(-2,-1),2,1)
c = 3
Z = zmlasso(A,b,c)
Z
```

R pacakge
```{r}

fun <- function(x,y)
{
  A = matrix(c(2,1,1,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  return(exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*(abs(y)))))
}
```

```{r}
xmin <- -Inf; xmax <- Inf
ymin <- -Inf; ymax <- Inf
# Normalizing constant
dblquad(fun, xmin, xmax, ymin, ymax)
# integral2(fun, xmin, xmax, ymin, ymax)
```







# Test the moment function INTEGRATE WITH R PACKAGE
MOMENT FUNCTION OF TRUNCATED NORMAL(TWO WAYS)

```{r}
lower = 0
upper = Inf
A_inv = solve(A)
Sigma1 = A_inv
mu1 = A_inv%*%(b-c)

Sigma1 = A_inv
mom.mtruncnorm(powers = 1, mu1, Sigma1, rep(lower,2), rep(upper,2))$cum1
mom.mtruncnorm(powers = 2, mu1, Sigma1, rep(lower,2), rep(upper,2))$order2$m2
```
```{r}
library(tmvtnorm)
res = mtmvnorm(mean=as.vector(mu1), sigma=Sigma1,lower=rep(lower,2), upper=rep(upper,2))
print(res$tmean)
res$tvar + res$tmean %*% t(res$tmean)
```




Test Expectation of Positively Truncated Normal
```{r}
Z = zmlasso(A,b,c)
xmin <- 0; xmax <- Inf
ymin <- 0; ymax <- Inf

xfun <- function(x,y)
{
  A = matrix(c(2,0,0,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  A_inv = solve(A)
  mu1 = A_inv%*%(b-c)
  k = -0.5*((x-mu1[1])^2 * A[1,1] + A[1,2]*A[2,1]*(x-mu1[1])*(y-mu1[2]) + (y-mu1[2])^2*A[2,2])
  q = (b[1]-c)*x + (b[2]-c)*y
  
  # vx = matrix(c(x,y))
  value = x*exp(k + q)
  # value = exp(-0.5*t(vx-mu1)%*%A%*%(vx-mu1) + 0.5*(t(mu1)%*%solve(A)%*%mu1))
    # value = exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*x-c*(y)))
  return(value)
}

yfun <- function(x,y)
{
  A = matrix(c(2,0,0,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  A_inv = solve(A)
  mu1 = A_inv%*%(b-c)
  k = -0.5*((x-mu1[1])^2 * A[1,1] + A[1,2]*A[2,1]*(x-mu1[1])*(y-mu1[2]) + (y-mu1[2])^2*A[2,2])
  q = (b[1]-c)*x + (b[2]-c)*y
  
  # vx = matrix(c(x,y))
  value = y*exp(k+q)
  # value = exp(-0.5*t(vx-mu1)%*%A%*%(vx-mu1) + 0.5*(t(mu1)%*%solve(A)%*%mu1))
    # value = exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*x-c*(y)))
  return(value)
}



print(dblquad(xfun, xmin, xmax, ymin, ymax)/Z)
print(dblquad(yfun, xmin, xmax, ymin, ymax))
```


```{r}
xmin <- -Inf; xmax <- 0
ymin <- 0; ymax <- Inf
print(dblquad(xfun, xmin, xmax, ymin, ymax))
print(dblquad(yfun, xmin, xmax, ymin, ymax))
```






## Test Expectation of Multivariate Lasso Distribution


```{r}
xmin <- -Inf; xmax <- Inf
ymin <- -Inf; ymax <- Inf

actual_xfun <- function(x,y)
{
  A = matrix(c(2,1,1,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  return(x*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

actual_yfun <- function(x,y)
{
  A = matrix(c(2,1,1,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  return(y*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

# Expectation
vx = c()
vy = c()
vx[1] = dblquad(actual_xfun, xmin, xmax, ymin, ymax)
vy[1] = dblquad(actual_yfun, xmin, xmax, ymin, ymax)
print(c(vx[1],vy[1])/Z)
# integral2(fun, xmin, xmax, ymin, ymax)
```




```{r}
xmin <- -Inf; xmax <- 0
ymin <- 0; ymax <- Inf
vx[2]= dblquad(actual_xfun, xmin, xmax, ymin, ymax)
vy[2]= dblquad(actual_yfun, xmin, xmax, ymin, ymax)
print(c(vx[2],vy[2]))
```




```{r}
xmin <- 0; xmax <- Inf
ymin <- -Inf; ymax <- 0
vx[3] = dblquad(actual_xfun, xmin, xmax, ymin, ymax)
vy[3] = dblquad(actual_yfun, xmin, xmax, ymin, ymax)
print(c(vx[3],vy[3]))
```

```{r}
xmin <- -Inf; xmax <- 0
ymin <- -Inf; ymax <- 0
vx[4]= dblquad(actual_xfun, xmin, xmax, ymin, ymax)
vy[4] = dblquad(actual_yfun, xmin, xmax, ymin, ymax)
print(c(vx[4],vy[4]))
```
```{r}
print(c(sum(vx), sum(vy)))/Z
```





# My code result
```{r}
A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
b = c(-9.780891,13.613476)
c = 2.941653
source(here("code","lasso_distribution","Multi-Lasso.R")) 
Z = zmlasso(A,b,c)
emlasso(A,b,c)
```



# True Result from R package
```{r}
xmin <- -Inf; xmax <- Inf
ymin <- -Inf; ymax <- Inf

actual_xfun <- function(x,y)
{
  A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
  b = c(-9.780891,13.613476)
  c = 2.941653
  return(x*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

actual_yfun <- function(x,y)
{
  A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
  b = c(-9.780891,13.613476)
  c = 2.941653
  return(y*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

# Expectation
vx = c()
vy = c()
final1 = dblquad(actual_xfun, xmin, xmax, ymin, ymax)
final2 = dblquad(actual_yfun, xmin, xmax, ymin, ymax)


print(c(final1,final2)/Z)
```



# Test result of Variance function

My code
```{r}
A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
b = c(-9.780891,13.613476)
c = 2.941653
source(here("code","lasso_distribution","Multi-Lasso.R")) 
Z = zmlasso(A,b,c)
vmlasso(A,b,c)
```


# R code
```{r}

xmin <- -Inf; xmax <- Inf
ymin <- -Inf; ymax <- Inf

actual_xfun <- function(x,y)
{
  A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
  b = c(-9.780891,13.613476)
  c = 2.941653
  return(x^2*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

actual_yfun <- function(x,y)
{

  A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
  b = c(-9.780891,13.613476)
  c = 2.941653
  return(y^2*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

actual_xyfun <- function(x,y)
{
  A = matrix(c(68.32707,50.43952,50.43952,64.94208),2,2)
  b = c(-9.780891,13.613476)
  c = 2.941653
  return(x*y*exp((-0.5*(A[1,1]*x^2+(A[1,2]+A[2,1])*x*y+A[2,2]*y^2) + b[1]*x + b[2]*y -  c*abs(x)-c*abs(y))))
}

# Expectation
Z = zmlasso(A,b,c)
vx = c()
vy = c()
x2 = dblquad(actual_xfun, xmin, xmax, ymin, ymax)/Z
y2 = dblquad(actual_yfun, xmin, xmax, ymin, ymax)/Z
xy = dblquad(actual_xyfun, xmin, xmax, ymin, ymax)/Z

ex2 = matrix(c(x2,xy,xy,y2),2,2)
print(ex2)
print(ex2 - emlasso(A,b,c) %*% t(emlasso(A,b,c)))
```




```{r}
source(here("code/lasso_distribution","lasso_distribution.R"))
fun <- function(x)
{
  A = matrix(c(40,2,2,3),2,2)
  b = matrix(c(-2,-1),2,1)
  c = 3
  sigma2 = 1/A[2,2]
  Z <- zmlasso(A,b,c)
  
  
  sigma2 = 1/A[2,2]
  Z <- zmlasso(A,b,c)
  k = exp(-0.5*A[1,1]*x^2+b[1]*x-c*abs(x))/Z
  mu1 = -0.5*((A[1,2]+A[2,1])/A[2,2])*x + (b[2]-c)/A[2,2]
  mu2 = 0.5*((A[1,2]+A[2,1])/A[2,2])*x - (b[2]+c)/A[2,2]
  
  log_partI  <- pnorm(mu1/sqrt(sigma2),log=TRUE)  - dnorm(mu1/sqrt(sigma2),log=TRUE)
  log_partII <- pnorm(mu2/sqrt(sigma2),log=TRUE) - dnorm(mu2/sqrt(sigma2),log=TRUE)
  
  M <- max(c(log_partI,log_partII))
  log_mpdf =  log(sqrt(sigma2)) + log(k) + M +log(exp(log_partI - M)+exp(log_partII - M))
  
  return(exp(log_mpdf))

  
}

integrate(fun,lower = -3, upper = 3)
```

